// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  angular.module('protocole_map_carre', []).factory('ProtocoleMapCarre', function($rootScope, Backend, GoogleMaps, ProtocoleMap) {
    var ProtocoleMapCarre;
    return ProtocoleMapCarre = (function(superClass) {
      extend(ProtocoleMapCarre, superClass);

      function ProtocoleMapCarre(mapDiv, typeProtocole, callbacks) {
        this.typeProtocole = typeProtocole;
        this.callbacks = callbacks;
        this.saveOverlay = bind(this.saveOverlay, this);
        ProtocoleMapCarre.__super__.constructor.call(this, mapDiv, this.typeProtocole, this.callbacks);
        this._min = 5;
        this._max = 13;
        this._steps = [
          {
            id: 'start',
            message: "Positionner la zone de sélection aléatoire."
          }, {
            id: 'selectGrilleStoc',
            message: "Cliquer sur la carte pour sélection la grille stoc correspondante."
          }, {
            id: 'editLocalities',
            message: "Définir vos points à l'intérieur du carré."
          }, {
            id: 'validLocalities',
            message: "Valider les points."
          }, {
            id: 'end',
            message: "Cartographie achevée."
          }
        ];
        this._googleMaps.setDrawingManagerOptions({
          drawingControlOptions: {
            position: google.maps.ControlPosition.TOP_CENTER,
            drawingModes: [google.maps.drawing.OverlayType.MARKER]
          }
        });
        this._googleMaps.setDrawingManagerOptions({
          drawingControl: false
        });
      }

      ProtocoleMapCarre.prototype.mapCallback = function() {
        return {
          onProjectionReady: (function(_this) {
            return function() {
              _this._projectionReady = true;
              return _this.loadMapEditContinue();
            };
          })(this),
          overlayCreated: (function(_this) {
            return function(overlay) {
              var base, base1, isModified;
              isModified = false;
              if (_this._step === 'selectGrilleStoc') {
                _this.getGrilleStoc(overlay);
                return false;
              } else {
                if (overlay.type === "Point") {
                  if (_this._googleMaps.isPointInPolygon(overlay, _this._grilleStoc.overlay)) {
                    isModified = true;
                  }
                } else {
                  if (typeof (base = _this.callbacks).displayError === "function") {
                    base.displayError("Mauvaise forme : " + overlay.type);
                  }
                }
                if (isModified) {
                  if (_this._isOpportuniste) {
                    _this.saveOverlay(overlay);
                    _this._googleMaps.addListener(overlay, 'rightclick', function(e) {
                      _this.deleteOverlay(overlay);
                      if (_this.getCountOverlays() < 1) {
                        _this._step = 'editLocalities';
                      } else {
                        _this._step = 'validLocalities';
                      }
                      return _this.updateSite();
                    });
                    _this._step = 'validLocalities';
                  } else {
                    if (_this.getCountOverlays() >= _this._max) {
                      if (typeof (base1 = _this.callbacks).displayError === "function") {
                        base1.displayError("Nombre maximum de points atteint.");
                      }
                      return false;
                    }
                    _this.saveOverlay(overlay);
                    _this.checkDistanceBetweenPoints(200);
                    _this._googleMaps.addListener(overlay, 'rightclick', function(e) {
                      _this.deleteOverlay(overlay);
                      _this.checkDistanceBetweenPoints(200);
                      if (_this.getCountOverlays() < _this._min) {
                        _this._step = 'editLocalities';
                      } else {
                        _this._step = 'validLocalities';
                      }
                      return _this.updateSite();
                    });
                    _this._googleMaps.addListener(overlay, 'mouseout', function(e) {
                      return _this.checkDistanceBetweenPoints(200);
                    });
                    if (_this.getCountOverlays() >= _this._min) {
                      _this._step = 'validLocalities';
                    } else {
                      _this._step = 'editLocalities';
                    }
                  }
                  _this.updateSite();
                  return true;
                }
                return false;
              }
            };
          })(this)
        };
      };

      ProtocoleMapCarre.prototype.saveOverlay = function(overlay) {
        var locality;
        locality = {};
        locality.overlay = overlay;
        locality.representatif = false;
        overlay.title = this.setLocalityName();
        overlay.infowindow = this._googleMaps.createInfoWindow(overlay.title);
        overlay.infowindow.open(this._googleMaps.getMap(), overlay);
        return this._localities.push(locality);
      };

      ProtocoleMapCarre.prototype.setLocalityName = function(name) {
        var k, l, len, len1, locality, ref, ref1;
        if (name == null) {
          name = 1;
        }
        if (this._isOpportuniste) {
          ref = this._fixLocalities;
          for (k = 0, len = ref.length; k < len; k++) {
            locality = ref[k];
            if (parseInt(locality.overlay.title) === name) {
              return this.setLocalityName(name + 1);
            }
          }
        }
        ref1 = this._localities;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          locality = ref1[l];
          if (parseInt(locality.overlay.title) === name) {
            return this.setLocalityName(name + 1);
          }
        }
        return name + '';
      };

      ProtocoleMapCarre.prototype.checkDistanceBetweenPoints = function(limit) {
        var base, base1, distance, firstLocality, i, j, k, l, overpass, ref, ref1, ref2, secondLocality;
        overpass = false;
        for (i = k = 0, ref = this._localities.length - 2; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          if (!(i >= 0)) {
            continue;
          }
          if (overpass) {
            break;
          }
          for (j = l = ref1 = i + 1, ref2 = this._localities.length - 1; ref1 <= ref2 ? l <= ref2 : l >= ref2; j = ref1 <= ref2 ? ++l : --l) {
            if (!(j < this._localities.length)) {
              continue;
            }
            firstLocality = this._localities[i];
            secondLocality = this._localities[j];
            if (firstLocality === secondLocality) {
              break;
            }
            distance = this._googleMaps.computeDistanceBetween(firstLocality.overlay.getPosition(), secondLocality.overlay.getPosition());
            if (distance < limit) {
              overpass = true;
              break;
            }
          }
        }
        if (overpass) {
          return typeof (base = this.callbacks).displayWarning === "function" ? base.displayWarning("Attention, point à moins de 200 mètres d'un autre point.", 'PROXIMITY_POINTS') : void 0;
        } else {
          return typeof (base1 = this.callbacks).hideWarning === "function" ? base1.hideWarning('PROXIMITY_POINTS') : void 0;
        }
      };

      return ProtocoleMapCarre;

    })(ProtocoleMap);
  });

}).call(this);
