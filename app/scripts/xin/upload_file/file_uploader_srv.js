// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  angular.module('xin.fileUploader', ['xin_s3uploadFile', 'appSettings']).factory('Uploader', function($interval, $http, Backend, S3FileUploader, SETTINGS) {
    var Uploader;
    return Uploader = (function() {
      function Uploader(elem, config) {
        this._computeSpeed = bind(this._computeSpeed, this);
        var input, onChange, onDrop, overClass, self;
        self = this;
        overClass = "drag-over";
        elem.addEventListener('dragover', function(e) {
          e.preventDefault();
          return elem.classList.add(overClass);
        }, false);
        elem.addEventListener('dragleave', function(e) {
          e.preventDefault();
          return elem.classList.remove(overClass);
        }, false);
        onDrop = function(e) {
          var files, items;
          e.preventDefault();
          elem.classList.remove(overClass);
          files = e.dataTransfer.files;
          if (files.length) {
            items = e.dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry != null)) {
              return self._addFilesFromItems(items);
            } else {
              return self._addFiles(files);
            }
          }
        };
        elem.addEventListener('drop', onDrop);
        input = elem.children[0];
        onChange = function() {
          return self._addFiles(this.files);
        };
        input.addEventListener('change', onChange);
        this.status = 'inactive';
        this.parallelUploads = config.parallelUploads || 5;
        this.accept = config.accept;
        this.sending = config.sending;
        this.complete = config.complete;
        this.refreshScope = config.refreshScope;
        this.participationId = config.participationId;
        this.queuedFiles = [];
        this.processingFiles = {};
        this.speed = 0;
        this.successes = [];
        this.warnings = [];
        this.errors = [];
        this._isCheckingTransmittedSize = false;
        this.transmittedSize = 0;
        this._startTime = new Date();
        this._interval = $interval(this._computeSpeed, 3000);
      }

      Uploader.prototype._addFilesFromItems = function(items) {
        var entry, i, item, len, results;
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          if ((item.webkitGetAsEntry != null) && (entry = item.webkitGetAsEntry())) {
            if (entry.isFile) {
              results.push(this._addFile(item.getAsFile()));
            } else if (entry.isDirectory) {
              results.push(this._addFilesFromDirectory(entry, entry.name));
            } else {
              results.push(void 0);
            }
          } else if (item.getAsFile != null) {
            if ((item.kind == null) || item.kind === "file") {
              results.push(this._addFile(item.getAsFile()));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      };

      Uploader.prototype._addFilesFromDirectory = function(directory, path) {
        var dirReader, errorHandler, readEntries;
        dirReader = directory.createReader();
        errorHandler = function(error) {
          return console.log(error);
        };
        readEntries = (function(_this) {
          return function() {
            return dirReader.readEntries(function(entries) {
              var entry, i, len;
              if (entries.length > 0) {
                for (i = 0, len = entries.length; i < len; i++) {
                  entry = entries[i];
                  if (entry.isFile) {
                    entry.file(function(file) {
                      file.fullPath = path + "/" + file.name;
                      return _this._addFile(file);
                    });
                  } else if (entry.isDirectory) {
                    _this._addFilesFromDirectory(entry, path + "/" + entry.name);
                  }
                }
                return readEntries();
              }
            }, errorHandler);
          };
        })(this);
        return readEntries();
      };

      Uploader.prototype._addFiles = function(files) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this._addFile(file));
        }
        return results;
      };

      Uploader.prototype._addFile = function(file) {
        this.status = 'active';
        this.queuedFiles.push(file);
        return this._checkQueuedFiles();
      };

      Uploader.prototype._checkQueuedFiles = function() {
        var file, results;
        if (!this.queuedFiles.length && !Object.keys(this.processingFiles).length) {
          return this.status = 'inactive';
        } else {
          results = [];
          while (this.queuedFiles.length && Object.keys(this.processingFiles).length < this.parallelUploads) {
            file = this.queuedFiles.shift();
            file = {
              data: file,
              type: file.type,
              name: file.name,
              fullPath: file.fullPath,
              status: "ready",
              gzip: true,
              transmittedSize: 0
            };
            this.processingFiles[file.fullPath || file.name] = file;
            results.push(this._accept(file));
          }
          return results;
        }
      };

      Uploader.prototype._accept = function(file) {
        var _acceptCallback;
        _acceptCallback = (function(_this) {
          return function(error) {
            if (error == null) {
              error = null;
            }
            if (error != null) {
              delete _this.processingFiles[file.fullPath || file.name];
              _this.refreshScope();
              return _this._checkQueuedFiles();
            } else {
              return _this._sending(file);
            }
          };
        })(this);
        return this.accept(file, _acceptCallback);
      };

      Uploader.prototype._sending = function(file) {
        file = new S3FileUploader(this.participationId, file, {
          onStart: (function(_this) {
            return function(s3File) {
              return s3File.file.status = 'progress';
            };
          })(this),
          onProgress: (function(_this) {
            return function(s3File, transmittedSize) {
              _this.transmittedSize += transmittedSize - s3File.file.transmittedSize;
              return s3File.file.transmittedSize = transmittedSize;
            };
          })(this),
          onPause: (function(_this) {
            return function(s3File) {
              return s3File.file.status = 'pause';
            };
          })(this),
          onSuccess: (function(_this) {
            return function(s3File) {
              _this.transmittedSize += s3File.file.data.size - s3File.file.transmittedSize;
              _this.successes.push(s3File.file.name);
              delete _this.processingFiles[s3File.file.fullPath || s3File.file.name];
              return _this._checkQueuedFiles();
            };
          })(this),
          onErrorBack: (function(_this) {
            return function(s3File, status) {
              _this.errors.push(s3File.file.name + " : " + (JSON.stringify(status.data._errors)));
              delete _this.processingFiles[s3File.file.fullPath || s3File.file.name];
              return _this._checkQueuedFiles();
            };
          })(this),
          onErrorS3: (function(_this) {
            return function(s3File, status) {
              console.error(status);
              _this.errors.push(s3File.file.name + " : " + (JSON.stringify(status.data._errors)));
              delete _this.processingFiles[s3File.file.fullPath || s3File.file.name];
              return _this._checkQueuedFiles();
            };
          })(this),
          onCancel: (function(_this) {
            return function(s3File) {
              _this._removeFileUploading(s3File);
              return _this.itemsCanceled.push({
                name: s3File.file.name
              });
            };
          })(this)
        });
        return file.start();
      };

      Uploader.prototype._computeSpeed = function() {
        var diffTime, now;
        now = new Date();
        diffTime = (now - this._startTime) / 1000;
        this._startTime = now;
        this.speed = this.transmittedSize / diffTime;
        return this.transmittedSize = 0;
      };

      Uploader.prototype.clearErrors = function() {
        this.warnings = [];
        return this.errors = [];
      };

      return Uploader;

    })();
  });

}).call(this);
