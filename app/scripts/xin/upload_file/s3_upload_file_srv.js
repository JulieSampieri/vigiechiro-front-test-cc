// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';
  angular.module('xin_s3uploadFile', ['appSettings']).directive('accessFileDirective', function(SETTINGS, Backend) {
    return {
      restrict: 'E',
      template: '<button class="btn btn-primary" ng-click="accessFile()">{{file.titre}}</button>',
      scope: {
        file: '='
      },
      link: function(scope, elem, attrs) {
        var btn;
        if ((scope.file != null) && (scope.file.disponible != null) && (scope.file.s3_id != null)) {
          scope.fileLink = SETTINGS.API_DOMAIN + "/fichiers/" + scope.file._id + "/acces";
          return scope.accessFile = function() {
            return Backend.all('fichiers').one(scope.file._id).customGET('acces').then(function(response) {
              return window.open(response.s3_signed_url);
            }, function(error) {
              if (error.status === 410) {

              } else {
                throw error;
              }
            });
          };
        } else {
          btn = elem.find('button');
          btn.removeClass('btn-primary', '');
          btn.addClass('btn-warning', '');
          btn.attr('data-toggle', 'tooltip');
          btn.attr('data-placement', 'top');
          btn.attr('title', "Ce fichier n'est pas disponible en ligne");
          return btn.tooltip();
        }
      }
    };
  }).directive('accessPhotoDirective', function(SETTINGS, Backend) {
    return {
      restrict: 'E',
      template: '<img ng-src="{{s3_signed_url}}"</img><span ng-show="onError">{{error}}</span>',
      scope: {
        file: '='
      },
      link: function(scope, elem, attrs) {
        if ((scope.file.disponible != null) && (scope.file.s3_id != null)) {
          scope.fileLink = SETTINGS.API_DOMAIN + "/fichiers/" + scope.file._id + "/acces";
          return Backend.all('fichiers').one(scope.file._id).customGET('acces').then(function(response) {
            return scope.s3_signed_url = response.s3_signed_url;
          }, function(error) {
            if (error.status === 410) {

            } else {
              throw error;
            }
          });
        } else {
          scope.onError = true;
          return scope.error = "Cette image n'est pas disponible en ligne";
        }
      }
    };
  }).service('S3FileUploader', function($q, Backend) {
    var S3FileUploader, uploadToS3;
    uploadToS3 = function(callbacks, verb, file, url, headers) {
      var key, ref, value, xhr;
      xhr = new XMLHttpRequest();
      if (xhr.withCredentials != null) {
        xhr.open(verb, url, true);
      } else if (typeof XDomainRequest !== "undefined") {
        xhr = new XDomainRequest();
        xhr.open(verb, url);
      } else {
        if (typeof callbacks.onError === "function") {
          callbacks.onError('CORS not supported');
        }
        return;
      }
      xhr.onload = function() {
        if (xhr.status === 200) {
          return typeof callbacks.onSuccess === "function" ? callbacks.onSuccess(xhr) : void 0;
        } else {
          return typeof callbacks.onError === "function" ? callbacks.onError('Upload error: ' + xhr.status) : void 0;
        }
      };
      xhr.onerror = function() {
        return typeof callbacks.onError === "function" ? callbacks.onError('XHR error.') : void 0;
      };
      xhr.upload.onprogress = function(e) {
        if (e.lengthComputable) {
          return typeof callbacks.onProgress === "function" ? callbacks.onProgress(e.loaded, e.total) : void 0;
        }
      };
      ref = headers || {};
      for (key in ref) {
        value = ref[key];
        xhr.setRequestHeader(key, value);
      }
      return xhr.send(file.data);
    };
    return S3FileUploader = (function() {
      S3FileUploader.prototype.sliceSize = 50 * 1024 * 1024;

      function S3FileUploader(participationId, file, userCallbacks) {
        this.participationId = participationId;
        this.userCallbacks = userCallbacks;
        this.file = file;
        this._pause = $q.defer();
        this._context = void 0;
      }

      S3FileUploader.prototype._onSuccess = function() {
        var base;
        return typeof (base = this.userCallbacks).onSuccess === "function" ? base.onSuccess(this) : void 0;
      };

      S3FileUploader.prototype._onProgress = function(loaded, total) {
        return this._pause.promise.then((function(_this) {
          return function() {
            var base;
            return typeof (base = _this.userCallbacks).onProgress === "function" ? base.onProgress(_this, loaded) : void 0;
          };
        })(this));
      };

      S3FileUploader.prototype._onErrorBack = function(status) {
        var base;
        return typeof (base = this.userCallbacks).onErrorBack === "function" ? base.onErrorBack(this, status) : void 0;
      };

      S3FileUploader.prototype._onErrorS3 = function(status) {
        var base;
        return typeof (base = this.userCallbacks).onErrorXhr === "function" ? base.onErrorXhr(this, status) : void 0;
      };

      S3FileUploader.prototype.cancel = function() {
        var base;
        this._pause = $q.defer();
        return typeof (base = this.userCallbacks).onCancel === "function" ? base.onCancel(this) : void 0;
      };

      S3FileUploader.prototype.pause = function() {
        var base;
        if (typeof (base = this.userCallbacks).onPause === "function") {
          base.onPause(this);
        }
        return this._pause = $q.defer();
      };

      S3FileUploader.prototype.retry = function() {
        this.file.status === 'ready';
        this.file.transmitted_size = 0;
        return this.start();
      };

      S3FileUploader.prototype.start = function() {
        var base;
        this._pause.resolve();
        if (this.file.status === 'ready') {
          this._startSingleUpload();
          return typeof (base = this.userCallbacks).onStart === "function" ? base.onStart(this) : void 0;
        }
      };

      S3FileUploader.prototype._startMultiPartUpload = function() {
        var payload;
        payload = {
          mime: this.file.type,
          titre: this.file.name,
          multipart: true,
          lien_participation: this.participationId
        };
        if (payload.mime === '') {
          if (payload.titre.endsWith('.ta')) {
            payload.mime = 'application/ta';
          } else if (payload.titre.endsWith('.tac')) {
            payload.mime = 'application/tac';
          }
        }
        return Backend.all('fichiers').post(payload).then((function(_this) {
          return function(response) {
            _this.file.id = response._id;
            _this._context = {
              id: response._id,
              part_number: 1,
              transmitted_size: 0,
              file: _this.file,
              parts: []
            };
            return _this._continueMultiPartUpload();
          };
        })(this), (function(_this) {
          return function(error) {
            return _this._onErrorBack(error);
          };
        })(this));
      };

      S3FileUploader.prototype._continueMultiPartUpload = function() {
        return this._pause.promise.then((function(_this) {
          return function() {
            var end, fileBackend, payload, slice, start;
            fileBackend = Backend.all('fichiers').one(_this._context.id);
            start = (_this._context.part_number - 1) * _this.sliceSize;
            end = start + _this.sliceSize;
            slice = _this._context.file.slice(start, end);
            if (slice.size === 0) {
              payload = {
                parts: _this._context.parts
              };
              fileBackend.customPOST(payload).then(function() {
                return _this._onSuccess();
              }, function(e) {
                return _this._onErrorBack(e);
              });
              return;
            }
            return fileBackend.oneUrl('multipart').customPUT({
              part_number: _this._context.part_number
            }).then(function(response) {
              var callbacks, headers, lastSlicePercent;
              lastSlicePercent = 0;
              callbacks = {
                onProgress: function(loaded, total) {
                  var slicePercent;
                  if (total == null) {
                    return;
                  }
                  slicePercent = Math.round((loaded / total) * 100);
                  _this._context.transmitted_size += slice.size * (slicePercent - lastSlicePercent) / 100;
                  lastSlicePercent = slicePercent;
                  return typeof _this._onProgress === "function" ? _this._onProgress(_this._context.transmitted_size, _this._context.file.size) : void 0;
                },
                onSuccess: function(request) {
                  _this._context.parts.push({
                    part_number: _this._context.part_number,
                    etag: request.getResponseHeader("ETag")
                  });
                  _this._context.part_number += 1;
                  return _this._continueMultiPartUpload(_this._context);
                },
                onError: function(error) {
                  return _this._onErrorS3(error);
                }
              };
              headers = {};
              if (_this._gzip) {
                headers["Content-Encoding"] = "gzip";
              }
              return uploadToS3(callbacks, 'PUT', slice, response.s3_signed_url, headers);
            }, function(error) {
              return _this._onErrorBack(error);
            });
          };
        })(this));
      };

      S3FileUploader.prototype._startSingleUpload = function() {
        var callbacks, payload;
        payload = {
          mime: this.file.type,
          titre: this.file.name,
          multipart: false,
          lien_participation: this.participationId
        };
        if (payload.titre.endsWith('.ta.zip')) {
          payload.mime = 'application/ta+zip';
        } else if (payload.titre.endsWith('.tc.zip')) {
          payload.mime = 'application/tc+zip';
        } else if (payload.titre.endsWith('.wav.zip')) {
          payload.mime = 'application/wav+zip';
        }
        if (payload.mime === '') {
          if (payload.titre.endsWith('.ta')) {
            payload.mime = 'application/ta';
          } else if (payload.titre.endsWith('.tac')) {
            payload.mime = 'application/tac';
          }
        }
        callbacks = {
          onError: (function(_this) {
            return function(error) {
              return _this._onErrorS3(error);
            };
          })(this),
          onProgress: (function(_this) {
            return function(loaded, total) {
              return _this._onProgress(loaded, total);
            };
          })(this),
          onSuccess: (function(_this) {
            return function() {
              return Backend.one('fichiers', _this.file.id).get().then(function(fileBackend) {
                return fileBackend.post().then(function() {
                  return _this._onSuccess();
                }, function(error) {
                  return _this._onErrorBack(error);
                });
              });
            };
          })(this)
        };
        return Backend.all('fichiers').post(payload).then((function(_this) {
          return function(response) {
            var headers;
            _this.file.id = response._id;
            headers = {
              'Content-Type': payload.mime
            };
            if (_this.file.gzip) {
              headers["Content-Encoding"] = "gzip";
            }
            return uploadToS3(callbacks, 'PUT', _this.file, response.s3_signed_url, headers);
          };
        })(this), (function(_this) {
          return function(error) {
            return _this._onErrorBack(error);
          };
        })(this));
      };

      return S3FileUploader;

    })();
  });

}).call(this);
