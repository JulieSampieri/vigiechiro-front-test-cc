// Generated by CoffeeScript 1.12.7
(function() {
  'use strict';

  /**
    * args
   ## @div : element html (div) dans laquelle la map sera instanci√©e
   */
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  angular.module('xin_google_maps', []).factory('GoogleMaps', function($rootScope) {
    var GoogleMaps;
    return GoogleMaps = (function() {
      function GoogleMaps(div, callbackDict) {
        this.div = div;
        this.callbackDict = callbackDict != null ? callbackDict : {};
        this.overlayCreated = bind(this.overlayCreated, this);
        this._isMapCenteredOnSite = false;
        this.mapOptions = {
          center: new google.maps.LatLng(46.71109, 1.7191036),
          zoom: 6
        };
        this._map = new google.maps.Map(this.div, this.mapOptions);
        this._drawingManager = new google.maps.drawing.DrawingManager({
          drawingControl: true,
          markerOptions: {
            draggable: true
          },
          polygonOptions: {
            draggable: true,
            editable: true
          },
          polylineOptions: {
            draggable: true,
            editable: true
          },
          rectangleOptions: {
            draggable: true,
            editable: true
          }
        });
        this._drawingManager.setMap(this._map);
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition((function(_this) {
            return function(position) {
              var pos;
              if (!_this._isMapCenteredOnSite) {
                pos = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
                _this._map.setCenter(pos);
                return _this._map.setZoom(9);
              }
            };
          })(this));
        }
        if (this.callbackDict.zoomChanged != null) {
          google.maps.event.addListener(this._map, 'zoom_changed', this.callbackDict.zoomChanged);
        }
        if (this.callbackDict.mapsMoved != null) {
          google.maps.event.addListener(this._map, 'dragend', this.callbackDict.mapsMoved);
        }
        google.maps.event.addListener(this._drawingManager, 'overlaycomplete', this.overlayCreated);
        google.maps.event.addListenerOnce(this._map, "projection_changed", (function(_this) {
          return function() {
            var base;
            return typeof (base = _this.callbackDict).onProjectionReady === "function" ? base.onProjectionReady() : void 0;
          };
        })(this));
      }

      GoogleMaps.prototype.overlayCreated = function(e) {
        var base, new_overlay;
        new_overlay = e.overlay;
        if (e.type === google.maps.drawing.OverlayType.MARKER) {
          new_overlay.type = "Point";
        } else if (e.type === google.maps.drawing.OverlayType.POLYGON) {
          new_overlay.type = "Polygon";
        } else if (e.type === google.maps.drawing.OverlayType.POLYLINE) {
          new_overlay.type = "LineString";
        } else {
          return;
        }
        if (!(typeof (base = this.callbackDict).overlayCreated === "function" ? base.overlayCreated(new_overlay) : void 0)) {
          return new_overlay.setMap(null);
        }
      };

      GoogleMaps.prototype.addListener = google.maps.event.addListener;

      GoogleMaps.prototype.clearListeners = google.maps.event.clearListeners;

      GoogleMaps.prototype.displayInfo = function(overlay) {
        var infoWindow;
        infoWindow = new google.maps.InfoWindow();
        infoWindow.setContent("lat : " + overlay.getPosition().lat() + ", lng : " + overlay.getPosition().lng());
        return infoWindow.open(this._map, overlay);
      };

      GoogleMaps.prototype.getZoom = function() {
        return this._map.getZoom();
      };

      GoogleMaps.prototype.setZoom = function(level) {
        return this._map.setZoom(level);
      };

      GoogleMaps.prototype.getCenter = function() {
        return this._map.getCenter();
      };

      GoogleMaps.prototype.setCenter = function(lat, lng) {
        this._isMapCenteredOnSite = true;
        return this._map.setCenter(new google.maps.LatLng(lat, lng));
      };

      GoogleMaps.prototype.fitBounds = function(latLngBounds) {
        return this._map.fitBounds(latLngBounds);
      };

      GoogleMaps.prototype.getBounds = function() {
        return this._map.getBounds();
      };

      GoogleMaps.prototype.getMap = function() {
        return this._map;
      };

      GoogleMaps.prototype.setDrawingManagerOptions = function(options) {
        return this._drawingManager.setOptions(options);
      };

      GoogleMaps.prototype.isPointInPolygon = function(marker, polygon) {
        var result;
        result = google.maps.geometry.poly.containsLocation(marker.getPosition(), polygon);
        return result;
      };

      GoogleMaps.prototype.isPolyInPolygon = function(poly, polygon) {
        var i, j, ref, vertices;
        vertices = poly.getPath();
        for (i = j = 0, ref = vertices.getLength() - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (!google.maps.geometry.poly.containsLocation(vertices.getAt(i), polygon)) {
            return false;
          }
        }
        return true;
      };

      GoogleMaps.prototype.createLatLng = function(lat, lng) {
        return new latLng(lat, lng);
      };

      GoogleMaps.prototype.createPoint = function(lat, lng, draggable, title) {
        var latlng;
        if (draggable == null) {
          draggable = false;
        }
        if (title == null) {
          title = '';
        }
        latlng = new google.maps.LatLng(lat, lng);
        return this.createPointWithLatLng(latlng, draggable, title);
      };

      GoogleMaps.prototype.createPointWithLatLng = function(latlng, draggable, title) {
        var point;
        if (draggable == null) {
          draggable = false;
        }
        if (title == null) {
          title = '';
        }
        point = new google.maps.Marker({
          position: latlng,
          map: this._map,
          draggable: draggable,
          title: title
        });
        return point;
      };

      GoogleMaps.prototype.createInfoWindow = function(content, zIndex) {
        if (zIndex == null) {
          zIndex = 1;
        }
        return new google.maps.InfoWindow({
          content: content,
          zIndex: zIndex
        });
      };

      GoogleMaps.prototype.createCircle = function(center, radius, draggable, editable) {
        if (draggable == null) {
          draggable = false;
        }
        if (editable == null) {
          editable = false;
        }
        return new google.maps.Circle({
          map: this._map,
          center: center,
          radius: radius,
          draggable: draggable,
          editable: editable
        });
      };

      GoogleMaps.prototype.createBounds = function(sw, ne) {
        var bounds;
        if (sw == null) {
          sw = null;
        }
        if (ne == null) {
          ne = null;
        }
        bounds = new google.maps.LatLngBounds();
        if (sw) {
          bounds.extend(sw);
        }
        if (ne) {
          bounds.extend(ne);
        }
        return bounds;
      };

      GoogleMaps.prototype.extendBounds = function(bounds, latlng) {
        var point;
        point = new google.maps.LatLng(latlng[0], latlng[1]);
        return bounds.extend(point);
      };

      GoogleMaps.prototype.createPolygon = function(latlngs, draggable, editable) {
        var j, latlng, len, paths, point;
        if (draggable == null) {
          draggable = false;
        }
        if (editable == null) {
          editable = false;
        }
        paths = [];
        for (j = 0, len = latlngs.length; j < len; j++) {
          latlng = latlngs[j];
          point = new google.maps.LatLng(latlng[0], latlng[1]);
          paths.push(point);
        }
        return this.createPolygonWithPaths(paths, draggable, editable);
      };

      GoogleMaps.prototype.createPolygonWithPaths = function(paths, draggable, editable) {
        var polygon;
        if (draggable == null) {
          draggable = false;
        }
        if (editable == null) {
          editable = false;
        }
        polygon = new google.maps.Polygon({
          paths: paths,
          map: this._map,
          draggable: draggable,
          editable: editable
        });
        return polygon;
      };

      GoogleMaps.prototype.createLineString = function(latlngs, draggable, editable) {
        var j, latlng, len, path, point;
        if (draggable == null) {
          draggable = false;
        }
        if (editable == null) {
          editable = false;
        }
        path = [];
        for (j = 0, len = latlngs.length; j < len; j++) {
          latlng = latlngs[j];
          point = new google.maps.LatLng(latlng[0], latlng[1]);
          path.push(point);
        }
        return this.createLineStringWithPath(path, draggable, editable);
      };

      GoogleMaps.prototype.createLineStringWithPath = function(path, draggable, editable) {
        var lineString;
        if (draggable == null) {
          draggable = false;
        }
        if (editable == null) {
          editable = false;
        }
        lineString = new google.maps.Polyline({
          path: path,
          map: this._map,
          draggable: draggable,
          editable: editable
        });
        return lineString;
      };

      GoogleMaps.prototype.getPosition = function(overlay) {
        return [overlay.getPosition().lat(), overlay.getPosition().lng()];
      };

      GoogleMaps.prototype.getPath = function(overlay) {
        var i, j, latlngs, ref, vertice, vertices;
        vertices = overlay.getPath();
        latlngs = [];
        for (i = j = 1, ref = vertices.getLength(); 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          vertice = vertices.getAt(i - 1);
          latlngs.push([vertice.lat(), vertice.lng()]);
        }
        return latlngs;
      };

      GoogleMaps.prototype.computeOffset = google.maps.geometry.spherical.computeOffset;

      GoogleMaps.prototype.computeLength = function(overlay) {
        if (overlay == null) {
          return 0;
        }
        return google.maps.geometry.spherical.computeLength(overlay.getPath());
      };

      GoogleMaps.prototype.computeDistanceBetween = google.maps.geometry.spherical.computeDistanceBetween;

      GoogleMaps.prototype.isLocationOnEdge = function(point, latlngs, tolerance) {
        var poly;
        if (tolerance == null) {
          tolerance = 10e-9;
        }
        poly = new google.maps.Polyline({
          path: latlngs
        });
        return google.maps.geometry.poly.isLocationOnEdge(point, poly, tolerance);
      };

      GoogleMaps.prototype.findClosestPointOnPath = function(drop_pt, path_pts, banned) {
        var ban, d, distance_keys, distances, j, k, key, len, ref, toBan;
        if (banned == null) {
          banned = [];
        }
        distances = [];
        distance_keys = [];
        for (key = j = 0, ref = path_pts.length - 1; 0 <= ref ? j <= ref : j >= ref; key = 0 <= ref ? ++j : --j) {
          toBan = false;
          for (k = 0, len = banned.length; k < len; k++) {
            ban = banned[k];
            if (path_pts[key].lat() === ban.getPosition().lat() && path_pts[key].lng() === ban.getPosition().lng()) {
              toBan = true;
              break;
            }
          }
          if (toBan) {
            continue;
          }
          d = google.maps.geometry.spherical.computeDistanceBetween(drop_pt, path_pts[key]);
          distances[key] = d;
          distance_keys[d] = key;
        }
        return path_pts[distance_keys[_.min(distances)]];
      };

      GoogleMaps.prototype.interpolate = function(from, to, fraction) {
        var latLngBetween, pointBetween, pointFrom, pointTo, projection, x, y;
        projection = this._map.getProjection();
        pointFrom = projection.fromLatLngToPoint(from);
        pointTo = projection.fromLatLngToPoint(to);
        if (Math.abs(pointTo.x - pointFrom.x) > 128) {
          if (pointTo.x > pointFrom.x) {
            pointTo.x -= 256;
          } else {
            pointTo.x += 256;
          }
        }
        x = pointFrom.x + (pointTo.x - pointFrom.x) * fraction;
        y = pointFrom.y + (pointTo.y - pointFrom.y) * fraction;
        pointBetween = new google.maps.Point(x, y);
        latLngBetween = projection.fromPointToLatLng(pointBetween);
        return latLngBetween;
      };

      GoogleMaps.prototype.trigger = google.maps.event.trigger;

      GoogleMaps.prototype.hideDrawingManager = function() {
        return this.setDrawingManagerOptions({
          drawingControl: false,
          drawingMode: ''
        });
      };

      return GoogleMaps;

    })();
  });

}).call(this);
